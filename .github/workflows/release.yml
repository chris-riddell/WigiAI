name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0
  workflow_dispatch:  # Allow manual triggering
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0)'
        required: false

jobs:
  build:
    name: Build macOS App
    runs-on: macos-14  # macOS Sonoma

    # Explicit permissions following principle of least privilege
    permissions:
      contents: write  # Needed to create releases and push appcast.xml to main branch

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Extract version from tag
        id: get_version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION=${{ github.event.inputs.version }}
          else
            VERSION="1.0.0"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Update version in Xcode project
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          BUILD_NUMBER="${{ github.run_number }}"

          # Update MARKETING_VERSION and CURRENT_PROJECT_VERSION
          xcrun agvtool new-marketing-version "$VERSION"
          xcrun agvtool new-version -all "$BUILD_NUMBER"

          echo "Updated to version $VERSION ($BUILD_NUMBER)"

      # Check if code signing certificates are available
      - name: Check for signing certificates
        id: check_certs
        env:
          CERT_EXISTS: ${{ secrets.CERTIFICATES_P12 }}
        run: |
          if [ -n "$CERT_EXISTS" ]; then
            echo "has_certs=true" >> $GITHUB_OUTPUT
          else
            echo "has_certs=false" >> $GITHUB_OUTPUT
          fi

      # Option 1: Build WITHOUT code signing (when no certificates configured)
      - name: Build app (unsigned)
        if: steps.check_certs.outputs.has_certs == 'false'
        run: |
          xcodebuild \
            -scheme WigiAI \
            -configuration Release \
            -derivedDataPath build \
            -arch arm64 -arch x86_64 \
            clean build \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

      # Option 2: Build WITH code signing (when certificates are configured)
      - name: Import signing certificate
        if: steps.check_certs.outputs.has_certs == 'true'
        env:
          CERTIFICATES_P12: ${{ secrets.CERTIFICATES_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          # Create keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$CERTIFICATES_P12" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign

          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          rm certificate.p12

      - name: Build app (unsigned, will sign after)
        if: steps.check_certs.outputs.has_certs == 'true'
        run: |
          # Build WITHOUT code signing
          xcodebuild \
            -scheme WigiAI \
            -configuration Release \
            -derivedDataPath build \
            -arch arm64 -arch x86_64 \
            clean build \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

      - name: Sign app with Developer ID
        if: steps.check_certs.outputs.has_certs == 'true'
        run: |
          # Find the built app
          APP_PATH=$(find build -name "WigiAI.app" -type d | head -n 1)
          echo "Built app at: $APP_PATH"

          # Sign the entire app bundle with Developer ID + hardened runtime + timestamps
          echo "Signing with Developer ID Application certificate..."

          # Sign nested content first (inside-out approach required for bundles)
          # Sign all frameworks
          find "$APP_PATH/Contents/Frameworks" -name "*.framework" -type d 2>/dev/null | while read -r framework; do
            echo "Signing framework: $framework"
            codesign --force --sign "${{ secrets.CODE_SIGN_IDENTITY }}" \
              --timestamp \
              --options runtime \
              "$framework/Versions/A" 2>/dev/null || \
            codesign --force --sign "${{ secrets.CODE_SIGN_IDENTITY }}" \
              --timestamp \
              --options runtime \
              "$framework"
          done

          # Sign all XPC services
          find "$APP_PATH/Contents" -name "*.xpc" -type d 2>/dev/null | while read -r xpc; do
            echo "Signing XPC service: $xpc"
            codesign --force --sign "${{ secrets.CODE_SIGN_IDENTITY }}" \
              --timestamp \
              --options runtime \
              "$xpc"
          done

          # Sign all helper apps
          find "$APP_PATH/Contents" -name "*.app" -type d 2>/dev/null | while read -r app; do
            echo "Signing helper app: $app"
            codesign --force --sign "${{ secrets.CODE_SIGN_IDENTITY }}" \
              --timestamp \
              --options runtime \
              "$app"
          done

          # Finally sign the main app bundle with entitlements
          echo "Signing main app bundle..."
          codesign --force --sign "${{ secrets.CODE_SIGN_IDENTITY }}" \
            --timestamp \
            --options runtime \
            --entitlements WigiAI/WigiAI.entitlements \
            "$APP_PATH"

          # Verify the signature
          echo "Verifying signature..."
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

          echo "‚úÖ App successfully signed with Developer ID"

      - name: Find built app
        id: find_app
        run: |
          APP_PATH=$(find build -name "WigiAI.app" -type d | head -n 1)
          echo "APP_PATH=$APP_PATH" >> $GITHUB_OUTPUT
          echo "Found app at: $APP_PATH"

      - name: Create DMG
        id: create_dmg
        run: |
          ./scripts/create_dmg.sh "${{ steps.find_app.outputs.APP_PATH }}" "WigiAI-${{ steps.get_version.outputs.VERSION }}.dmg"
          echo "DMG_PATH=WigiAI-${{ steps.get_version.outputs.VERSION }}.dmg" >> $GITHUB_OUTPUT

      - name: Notarize DMG
        if: steps.check_certs.outputs.has_certs == 'true'
        timeout-minutes: 180
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          echo "üìù Submitting DMG for notarization..."
          echo "‚è±Ô∏è  This can take a few minutes to several hours during peak times"

          # Submit and capture the submission ID
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "${{ steps.create_dmg.outputs.DMG_PATH }}" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --output-format json 2>&1)

          echo "Submission response: $SUBMISSION_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)

          if [ -z "$SUBMISSION_ID" ]; then
            echo "‚ùå Failed to get submission ID"
            echo "$SUBMISSION_OUTPUT"
            exit 1
          fi

          echo "‚úÖ Submission ID: $SUBMISSION_ID"
          echo "‚è≥ Waiting for Apple to process notarization (timeout: 2.5 hours)..."

          # Wait for notarization with generous timeout for peak times
          xcrun notarytool wait "$SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --timeout 150m

          # Check the final status
          echo "Checking notarization status..."
          STATUS_INFO=$(xcrun notarytool info "$SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID")

          echo "$STATUS_INFO"

          # Extract status
          STATUS=$(echo "$STATUS_INFO" | grep "status:" | awk '{print $2}')

          if [ "$STATUS" != "Accepted" ]; then
            echo "‚ùå Notarization failed with status: $STATUS"
            echo "Fetching detailed logs..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_ID_PASSWORD" \
              --team-id "$APPLE_TEAM_ID"
            exit 1
          fi

          echo "‚úÖ Notarization accepted! Stapling ticket to DMG..."

          # Staple the notarization ticket (embeds it in the DMG)
          xcrun stapler staple "${{ steps.create_dmg.outputs.DMG_PATH }}"

          echo "‚úÖ DMG is now notarized and stapled!"

      - name: Generate release notes
        id: release_notes
        run: |
          cat > release_notes.md << 'EOF'
          ## WigiAI v${{ steps.get_version.outputs.VERSION }}

          ### Installation

          1. Download `WigiAI-${{ steps.get_version.outputs.VERSION }}.dmg`
          2. Open the DMG file
          3. Drag WigiAI.app to your Applications folder
          4. Launch WigiAI from Applications folder

          **Note:** This release is code-signed and notarized by Apple for secure distribution.

          ### Troubleshooting

          If you encounter any issues opening the app:
          - Make sure you downloaded from the official GitHub releases page
          - Try redownloading if the DMG appears corrupted
          - Check that you're running macOS 14.0 (Sonoma) or later

          ### Requirements
          - macOS 14.0 (Sonoma) or later

          ### What's New
          - AI-powered desktop character companions
          - Habit tracking through conversational check-ins
          - Customizable characters with independent schedules
          - Real-time AI chat with streaming responses
          - Persistent chat history and context
          - Menubar integration
          - Launch on startup support
          - Automatic updates via Sparkle

          ---
          **Build:** ${{ github.run_number }} | **Commit:** ${{ github.sha }}
          EOF

          echo "RELEASE_NOTES_PATH=release_notes.md" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.get_version.outputs.VERSION }}
          name: WigiAI v${{ steps.get_version.outputs.VERSION }}
          body_path: release_notes.md
          files: ${{ steps.create_dmg.outputs.DMG_PATH }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for release asset to be available
        run: |
          echo "Polling for release asset availability..."
          GITHUB_USER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          GITHUB_REPO=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          TAG_NAME="v${{ steps.get_version.outputs.VERSION }}"
          DMG_NAME=$(basename "${{ steps.create_dmg.outputs.DMG_PATH }}")
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking if asset is available..."

            # Get the release and check if our DMG is in the assets
            ASSETS=$(gh api repos/$GITHUB_USER/$GITHUB_REPO/releases/tags/$TAG_NAME --jq '.assets[].name' 2>/dev/null || echo "")

            if echo "$ASSETS" | grep -q "$DMG_NAME"; then
              # Found the asset, now check if it's downloadable (returns 200)
              ASSET_URL=$(gh api repos/$GITHUB_USER/$GITHUB_REPO/releases/tags/$TAG_NAME --jq ".assets[] | select(.name == \"$DMG_NAME\") | .browser_download_url")
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L "$ASSET_URL")

              if [ "$HTTP_STATUS" = "200" ]; then
                echo "‚úÖ Asset is available and downloadable!"
                exit 0
              else
                echo "Asset found but not yet downloadable (HTTP $HTTP_STATUS), waiting..."
              fi
            else
              echo "Asset not found in release yet, waiting..."
            fi

            sleep 2
          done

          echo "‚ö†Ô∏è Timeout: Asset did not become available after $MAX_ATTEMPTS attempts"
          exit 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Sparkle appcast
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          GITHUB_USER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          GITHUB_REPO=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          VERSION="v${{ steps.get_version.outputs.VERSION }}"
          ./scripts/generate_appcast.sh "$GITHUB_USER" "$GITHUB_REPO" appcast.xml "" "$VERSION"

      - name: Update appcast in repository
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Reset any local changes from version update
          git reset --hard HEAD

          # Fetch and checkout main
          git fetch origin main
          git checkout main

          cp appcast.xml appcast.xml.new
          git add appcast.xml
          git commit -m "Update appcast for v${{ steps.get_version.outputs.VERSION }}" || echo "No changes to commit"
          git push origin main || echo "Nothing to push"

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: WigiAI-DMG
          path: ${{ steps.create_dmg.outputs.DMG_PATH }}
          retention-days: 90

      - name: Cleanup keychain
        if: always() && steps.check_certs.outputs.has_certs == 'true'
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
