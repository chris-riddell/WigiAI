//
//  UpdateService.swift
//  WigiAI
//
//  Manages automatic updates using Sparkle framework
//

import Foundation
import OSLog
import Sparkle
import AppKit

/// Delegate to suppress Sparkle error dialogs and log silently
private class SilentUpdaterDelegate: NSObject, SPUUpdaterDelegate {
    func updater(_ updater: SPUUpdater, didFinishLoading appcast: SUAppcast) {
        LoggerService.updates.debug("üì¶ Appcast loaded successfully")
    }

    func updater(_ updater: SPUUpdater, didAbortWithError error: Error) {
        LoggerService.updates.warning("‚ö†Ô∏è Update check aborted: \(error.localizedDescription)")
        // Don't show dialog - just log
    }

    func updaterDidNotFindUpdate(_ updater: SPUUpdater) {
        LoggerService.updates.debug("‚úÖ No updates available")
    }

    func updater(_ updater: SPUUpdater, failedToDownloadUpdate item: SUAppcastItem, error: Error) {
        LoggerService.updates.warning("‚ö†Ô∏è Failed to download update: \(error.localizedDescription)")
        // Don't show dialog - just log
    }
}

/// Service for managing automatic app updates via Sparkle framework
///
/// **Update Flow:**
/// 1. Sparkle checks GitHub releases for new versions
/// 2. Parses `appcast.xml` (auto-generated by GitHub Actions)
/// 3. Downloads DMG if newer version available
/// 4. Prompts user to install update
/// 5. Installs and relaunches app
///
/// **Configuration:**
/// - Update feed URL: Configured in `Info.plist` (`SUFeedURL` key)
/// - Check interval: 24 hours (86400 seconds)
/// - Auto-check: User-configurable in Settings
///
/// **GitHub Integration:**
/// - Releases triggered by version tags (`./scripts/bump_version.sh`)
/// - GitHub Actions builds DMG and generates appcast.xml
/// - Updates distributed via GitHub Releases (free hosting)
///
/// **User Control:**
/// - Can enable/disable automatic checks
/// - Manual check available in Settings
/// - Background checks don't interrupt work
class UpdateService: ObservableObject {
    /// Shared singleton instance
    static let shared = UpdateService()

    /// Sparkle updater controller
    private var updaterController: SPUStandardUpdaterController?

    /// Delegate to suppress error dialogs
    private let updaterDelegate = SilentUpdaterDelegate()

    /// When updates were last checked
    @Published var lastCheckDate: Date?

    /// Whether an update check is currently in progress
    @Published var isCheckingForUpdates = false

    /// Initializes service and sets up Sparkle updater
    private init() {
        setupUpdater()
    }

    /// Initializes Sparkle updater with configuration
    private func setupUpdater() {
        // Create the updater controller with silent delegate to suppress error dialogs
        // Use startingUpdater: false to manually start after setup
        updaterController = SPUStandardUpdaterController(
            startingUpdater: false,
            updaterDelegate: updaterDelegate,
            userDriverDelegate: nil
        )

        // Verify the updater was created
        if let updaterController = updaterController {
            let updater = updaterController.updater
            LoggerService.updates.info("‚úÖ UpdateService: Sparkle updater initialized successfully")
            LoggerService.updates.debug("   Feed URL: \(updater.feedURL?.absoluteString ?? "not set")")
            LoggerService.updates.debug("   Can check: \(updater.canCheckForUpdates)")

            // Start the updater manually to catch any errors
            do {
                try updaterController.startUpdater()
                LoggerService.updates.info("‚úÖ Sparkle updater started successfully")
            } catch {
                LoggerService.updates.warning("‚ö†Ô∏è Sparkle updater failed to start: \(error.localizedDescription)")
                LoggerService.updates.debug("   This is expected during development without a feed URL")
                // Don't show dialog - silently continue
            }
        } else {
            LoggerService.updates.error("‚ùå UpdateService: Sparkle updater failed to initialize")
        }

        // Configure based on settings
        configureFromSettings()
    }

    /// Configures updater based on current app settings
    ///
    /// Loads settings and applies auto-check preference and update interval.
    /// Called on init and whenever settings change.
    func configureFromSettings() {
        guard let updater = updaterController?.updater else {
            LoggerService.updates.warning("‚ö†Ô∏è UpdateService: Updater not available")
            return
        }

        let settings = StorageService.shared.loadSettings()

        // Enable/disable automatic checks
        updater.automaticallyChecksForUpdates = settings.autoUpdateEnabled

        // Set update interval to 24 hours (86400 seconds)
        updater.updateCheckInterval = 86400

        LoggerService.app.debug("üìù UpdateService: Configured - Auto-check: \(settings.autoUpdateEnabled), Interval: 24 hours")
    }

    /// Checks for updates in background (no UI if already up to date)
    ///
    /// Use this for automatic/periodic update checks. Won't show UI unless
    /// a new version is available.
    func checkForUpdatesInBackground() {
        guard let updater = updaterController?.updater else {
            LoggerService.updates.warning("‚ö†Ô∏è UpdateService: Cannot check for updates - updater not available")
            return
        }

        isCheckingForUpdates = true
        lastCheckDate = Date()

        // Check for updates in background (no UI if already up to date)
        updater.checkForUpdatesInBackground()

        // Reset checking state after a delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.isCheckingForUpdates = false
        }

        LoggerService.app.debug("üîç UpdateService: Checking for updates in background...")
    }

    /// Checks for updates and shows UI regardless of result
    ///
    /// Use this for user-initiated checks (e.g., from Settings menu).
    /// Always shows result dialog (either "up to date" or "update available").
    func checkForUpdates() {
        guard let updaterController = updaterController else {
            LoggerService.updates.error("‚ùå UpdateService: Cannot check for updates - controller not available")
            showUpdaterNotAvailableAlert()
            return
        }

        let updater = updaterController.updater

        // Check if updater can check for updates
        guard updater.canCheckForUpdates else {
            LoggerService.updates.error("‚ùå UpdateService: Updater reports it cannot check for updates")
            LoggerService.updates.debug("   Feed URL: \(updater.feedURL?.absoluteString ?? "nil")")
            showUpdaterConfigurationAlert()
            return
        }

        isCheckingForUpdates = true
        lastCheckDate = Date()

        LoggerService.app.debug("üîç UpdateService: Checking for updates (with UI)...")

        // Show update UI regardless of result
        updaterController.checkForUpdates(nil)

        // Reset checking state after a delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.isCheckingForUpdates = false
        }
    }

    /// Shows alert when updater is not available
    private func showUpdaterNotAvailableAlert() {
        DispatchQueue.main.async {
            let alert = NSAlert()
            alert.messageText = "Update Check Not Available"
            alert.informativeText = "The update system is not properly initialized. Please restart the app and try again."
            alert.alertStyle = .warning
            alert.addButton(withTitle: "OK")
            alert.runModal()
        }
    }

    /// Shows alert when updater configuration is invalid
    private func showUpdaterConfigurationAlert() {
        DispatchQueue.main.async {
            let alert = NSAlert()
            alert.messageText = "Update Configuration Error"
            alert.informativeText = "The update feed URL is not configured correctly. Please check the app's Info.plist file."
            alert.alertStyle = .warning
            alert.addButton(withTitle: "OK")
            alert.runModal()
        }
    }

    /// Enables or disables automatic update checks
    ///
    /// - Parameter enabled: Whether to automatically check for updates
    ///
    /// **Note:** Update interval is always 24 hours when enabled
    func setAutoUpdateEnabled(_ enabled: Bool) {
        guard let updater = updaterController?.updater else { return }

        updater.automaticallyChecksForUpdates = enabled
        updater.updateCheckInterval = 86400  // Always 24 hours
        LoggerService.app.debug("üìù UpdateService: Automatic updates \(enabled ? "enabled" : "disabled") - checking daily")
    }

    /// Gets current app version (e.g., "1.0.0")
    ///
    /// - Returns: Version string from `CFBundleShortVersionString`, or "Unknown"
    var currentVersion: String {
        if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String {
            return version
        }
        return "Unknown"
    }

    /// Gets current app build number (e.g., "42")
    ///
    /// - Returns: Build string from `CFBundleVersion`, or "Unknown"
    var currentBuild: String {
        if let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
            return build
        }
        return "Unknown"
    }

    /// Gets full version string combining version and build (e.g., "1.0.0 (42)")
    ///
    /// - Returns: Formatted version string for display in UI
    var versionString: String {
        return "\(currentVersion) (\(currentBuild))"
    }
}
